import { ServiceInterfaceType } from "../types";
import { AddressInfo, Host, Hostname, HostnameInfo } from "../types";
import { Effects } from "../Effects";
export type UrlString = string;
export type HostId = string;
export declare const getHostname: (url: string) => Hostname | null;
type FilterKinds = "onion" | "local" | "domain" | "ip" | "ipv4" | "ipv6";
export type Filter = {
    visibility?: "public" | "private";
    kind?: FilterKinds | FilterKinds[];
    exclude?: Filter;
};
type Formats = "hostname-info" | "urlstring" | "url";
type FormatReturnTy<Format extends Formats> = Format extends "hostname-info" ? HostnameInfo : Format extends "url" ? URL : UrlString;
export type Filled = {
    hostnames: HostnameInfo[];
    filter: <Format extends Formats = "urlstring">(filter: Filter, format?: Format) => FormatReturnTy<Format>[];
    publicHostnames: HostnameInfo[];
    onionHostnames: HostnameInfo[];
    localHostnames: HostnameInfo[];
    ipHostnames: HostnameInfo[];
    ipv4Hostnames: HostnameInfo[];
    ipv6Hostnames: HostnameInfo[];
    nonIpHostnames: HostnameInfo[];
    urls: UrlString[];
    publicUrls: UrlString[];
    onionUrls: UrlString[];
    localUrls: UrlString[];
    ipUrls: UrlString[];
    ipv4Urls: UrlString[];
    ipv6Urls: UrlString[];
    nonIpUrls: UrlString[];
};
export type FilledAddressInfo = AddressInfo & Filled;
export type ServiceInterfaceFilled = {
    id: string;
    /** The title of this field to be displayed */
    name: string;
    /** Human readable description, used as tooltip usually */
    description: string;
    /** Whether or not to mask the URIs for this interface. Useful if the URIs contain sensitive information, such as a password, macaroon, or API key */
    masked: boolean;
    /** Information about the host for this binding */
    host: Host | null;
    /** URI information */
    addressInfo: FilledAddressInfo | null;
    /** Indicates if we are a ui/p2p/api for the kind of interface that this is representing */
    type: ServiceInterfaceType;
};
export declare const addressHostToUrl: ({ scheme, sslScheme, username, suffix }: AddressInfo, host: HostnameInfo) => UrlString[];
export declare const filledAddress: (host: Host, addressInfo: AddressInfo) => FilledAddressInfo;
export declare class GetServiceInterface {
    readonly effects: Effects;
    readonly opts: {
        id: string;
        packageId?: string;
    };
    constructor(effects: Effects, opts: {
        id: string;
        packageId?: string;
    });
    /**
     * Returns the requested service interface. Reruns the context from which it has been called if the underlying value changes
     */
    const(): Promise<ServiceInterfaceFilled | null>;
    /**
     * Returns the requested service interface. Does nothing if the value changes
     */
    once(): Promise<ServiceInterfaceFilled | null>;
    /**
     * Watches the requested service interface. Returns an async iterator that yields whenever the value changes
     */
    watch(): AsyncGenerator<ServiceInterfaceFilled | null, void, unknown>;
    /**
     * Watches the requested service interface. Takes a custom callback function to run whenever the value changes
     */
    onChange(callback: (value: ServiceInterfaceFilled | null, error?: Error) => void | Promise<void>): void;
    /**
     * Watches the requested service interface. Returns when the predicate is true
     */
    waitFor(pred: (value: ServiceInterfaceFilled | null) => boolean): Promise<ServiceInterfaceFilled | null>;
}
export declare function getServiceInterface(effects: Effects, opts: {
    id: string;
    packageId?: string;
}): GetServiceInterface;
export {};
