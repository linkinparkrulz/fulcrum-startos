"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetServiceInterface = exports.filledAddress = exports.addressHostToUrl = exports.getHostname = void 0;
exports.getServiceInterface = getServiceInterface;
const Host_1 = require("../interfaces/Host");
const getHostnameRegex = /^(\w+:\/\/)?([^\/\:]+)(:\d{1,3})?(\/)?/;
const getHostname = (url) => {
    const founds = url.match(getHostnameRegex)?.[2];
    if (!founds)
        return null;
    const parts = founds.split("@");
    const last = parts[parts.length - 1];
    return last;
};
exports.getHostname = getHostname;
const either = (...args) => (a) => args.some((x) => x(a));
const negate = (fn) => (a) => !fn(a);
const unique = (values) => Array.from(new Set(values));
const addressHostToUrl = ({ scheme, sslScheme, username, suffix }, host) => {
    const res = [];
    const fmt = (scheme, host, port) => {
        const excludePort = scheme &&
            scheme in Host_1.knownProtocols &&
            port === Host_1.knownProtocols[scheme].defaultPort;
        let hostname;
        if (host.kind === "onion") {
            hostname = host.hostname.value;
        }
        else if (host.kind === "ip") {
            if (host.hostname.kind === "domain") {
                hostname = `${host.hostname.subdomain ? `${host.hostname.subdomain}.` : ""}${host.hostname.domain}`;
            }
            else if (host.hostname.kind === "ipv6") {
                hostname = host.hostname.value.startsWith("fe80::")
                    ? `[${host.hostname.value}%${host.hostname.scopeId}]`
                    : `[${host.hostname.value}]`;
            }
            else {
                hostname = host.hostname.value;
            }
        }
        return `${scheme ? `${scheme}://` : ""}${username ? `${username}@` : ""}${hostname}${excludePort ? "" : `:${port}`}${suffix}`;
    };
    if (host.hostname.sslPort !== null) {
        res.push(fmt(sslScheme, host, host.hostname.sslPort));
    }
    if (host.hostname.port !== null) {
        res.push(fmt(scheme, host, host.hostname.port));
    }
    return res;
};
exports.addressHostToUrl = addressHostToUrl;
function filterRec(hostnames, filter, invert) {
    if (filter.visibility === "public")
        hostnames = hostnames.filter((h) => invert !== (h.kind === "onion" || h.public));
    if (filter.visibility === "private")
        hostnames = hostnames.filter((h) => invert !== (h.kind !== "onion" && !h.public));
    if (filter.kind) {
        const kind = new Set(Array.isArray(filter.kind) ? filter.kind : [filter.kind]);
        if (kind.has("ip")) {
            kind.add("ipv4");
            kind.add("ipv6");
        }
        hostnames = hostnames.filter((h) => invert !==
            ((kind.has("onion") && h.kind === "onion") ||
                (kind.has("local") &&
                    h.kind === "ip" &&
                    h.hostname.kind === "local") ||
                (kind.has("domain") &&
                    h.kind === "ip" &&
                    h.hostname.kind === "domain") ||
                (kind.has("ipv4") && h.kind === "ip" && h.hostname.kind === "ipv4") ||
                (kind.has("ipv6") && h.kind === "ip" && h.hostname.kind === "ipv6")));
    }
    if (filter.exclude)
        return filterRec(hostnames, filter.exclude, !invert);
    return hostnames;
}
const filledAddress = (host, addressInfo) => {
    const toUrl = exports.addressHostToUrl.bind(null, addressInfo);
    const hostnames = host.hostnameInfo[addressInfo.internalPort];
    return {
        ...addressInfo,
        hostnames,
        filter: (filter, format) => {
            const res = filterRec(hostnames, filter, false);
            if (format === "hostname-info")
                return res;
            const urls = res.flatMap(toUrl);
            if (format === "url")
                return urls.map((u) => new URL(u));
            return urls;
        },
        get publicHostnames() {
            return hostnames.filter((h) => h.kind === "onion" || h.public);
        },
        get onionHostnames() {
            return hostnames.filter((h) => h.kind === "onion");
        },
        get localHostnames() {
            return hostnames.filter((h) => h.kind === "ip" && h.hostname.kind === "local");
        },
        get ipHostnames() {
            return hostnames.filter((h) => h.kind === "ip" &&
                (h.hostname.kind === "ipv4" || h.hostname.kind === "ipv6"));
        },
        get ipv4Hostnames() {
            return hostnames.filter((h) => h.kind === "ip" && h.hostname.kind === "ipv4");
        },
        get ipv6Hostnames() {
            return hostnames.filter((h) => h.kind === "ip" && h.hostname.kind === "ipv6");
        },
        get nonIpHostnames() {
            return hostnames.filter((h) => h.kind === "ip" &&
                h.hostname.kind !== "ipv4" &&
                h.hostname.kind !== "ipv6");
        },
        get urls() {
            return this.hostnames.flatMap(toUrl);
        },
        get publicUrls() {
            return this.publicHostnames.flatMap(toUrl);
        },
        get onionUrls() {
            return this.onionHostnames.flatMap(toUrl);
        },
        get localUrls() {
            return this.localHostnames.flatMap(toUrl);
        },
        get ipUrls() {
            return this.ipHostnames.flatMap(toUrl);
        },
        get ipv4Urls() {
            return this.ipv4Hostnames.flatMap(toUrl);
        },
        get ipv6Urls() {
            return this.ipv6Hostnames.flatMap(toUrl);
        },
        get nonIpUrls() {
            return this.nonIpHostnames.flatMap(toUrl);
        },
    };
};
exports.filledAddress = filledAddress;
const makeInterfaceFilled = async ({ effects, id, packageId, callback, }) => {
    const serviceInterfaceValue = await effects.getServiceInterface({
        serviceInterfaceId: id,
        packageId,
        callback,
    });
    if (!serviceInterfaceValue) {
        return null;
    }
    const hostId = serviceInterfaceValue.addressInfo.hostId;
    const host = await effects.getHostInfo({
        packageId,
        hostId,
        callback,
    });
    const interfaceFilled = {
        ...serviceInterfaceValue,
        host,
        addressInfo: host
            ? (0, exports.filledAddress)(host, serviceInterfaceValue.addressInfo)
            : null,
    };
    return interfaceFilled;
};
class GetServiceInterface {
    constructor(effects, opts) {
        this.effects = effects;
        this.opts = opts;
    }
    /**
     * Returns the requested service interface. Reruns the context from which it has been called if the underlying value changes
     */
    async const() {
        const { id, packageId } = this.opts;
        const callback = this.effects.constRetry &&
            (() => this.effects.constRetry && this.effects.constRetry());
        const interfaceFilled = await makeInterfaceFilled({
            effects: this.effects,
            id,
            packageId,
            callback,
        });
        return interfaceFilled;
    }
    /**
     * Returns the requested service interface. Does nothing if the value changes
     */
    async once() {
        const { id, packageId } = this.opts;
        const interfaceFilled = await makeInterfaceFilled({
            effects: this.effects,
            id,
            packageId,
        });
        return interfaceFilled;
    }
    /**
     * Watches the requested service interface. Returns an async iterator that yields whenever the value changes
     */
    async *watch() {
        const { id, packageId } = this.opts;
        const resolveCell = { resolve: () => { } };
        this.effects.onLeaveContext(() => {
            resolveCell.resolve();
        });
        while (this.effects.isInContext) {
            let callback = () => { };
            const waitForNext = new Promise((resolve) => {
                callback = resolve;
                resolveCell.resolve = resolve;
            });
            yield await makeInterfaceFilled({
                effects: this.effects,
                id,
                packageId,
                callback,
            });
            await waitForNext;
        }
    }
    /**
     * Watches the requested service interface. Takes a custom callback function to run whenever the value changes
     */
    onChange(callback) {
        ;
        (async () => {
            for await (const value of this.watch()) {
                try {
                    await callback(value);
                }
                catch (e) {
                    console.error("callback function threw an error @ GetServiceInterface.onChange", e);
                }
            }
        })()
            .catch((e) => callback(null, e))
            .catch((e) => console.error("callback function threw an error @ GetServiceInterface.onChange", e));
    }
    /**
     * Watches the requested service interface. Returns when the predicate is true
     */
    async waitFor(pred) {
        const { id, packageId } = this.opts;
        const resolveCell = { resolve: () => { } };
        this.effects.onLeaveContext(() => {
            resolveCell.resolve();
        });
        while (this.effects.isInContext) {
            let callback = () => { };
            const waitForNext = new Promise((resolve) => {
                callback = resolve;
                resolveCell.resolve = resolve;
            });
            const res = await makeInterfaceFilled({
                effects: this.effects,
                id,
                packageId,
                callback,
            });
            if (pred(res)) {
                resolveCell.resolve();
                return res;
            }
            await waitForNext;
        }
        return null;
    }
}
exports.GetServiceInterface = GetServiceInterface;
function getServiceInterface(effects, opts) {
    return new GetServiceInterface(effects, opts);
}
//# sourceMappingURL=getServiceInterface.js.map