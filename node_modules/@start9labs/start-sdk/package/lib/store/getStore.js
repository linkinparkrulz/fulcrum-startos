"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetStore = void 0;
exports.getStore = getStore;
const util_1 = require("../util");
class GetStore {
    constructor(effects, path, options = {}) {
        this.effects = effects;
        this.path = path;
        this.options = options;
    }
    /**
     * Returns the value of Store at the provided path. Reruns the context from which it has been called if the underlying value changes
     */
    const() {
        return this.effects.store.get({
            ...this.options,
            path: (0, util_1.extractJsonPath)(this.path),
            callback: this.effects.constRetry &&
                (() => this.effects.constRetry && this.effects.constRetry()),
        });
    }
    /**
     * Returns the value of Store at the provided path. Does nothing if the value changes
     */
    once() {
        return this.effects.store.get({
            ...this.options,
            path: (0, util_1.extractJsonPath)(this.path),
        });
    }
    /**
     * Watches the value of Store at the provided path. Returns an async iterator that yields whenever the value changes
     */
    async *watch() {
        const resolveCell = { resolve: () => { } };
        this.effects.onLeaveContext(() => {
            resolveCell.resolve();
        });
        while (this.effects.isInContext) {
            let callback = () => { };
            const waitForNext = new Promise((resolve) => {
                callback = resolve;
                resolveCell.resolve = resolve;
            });
            yield await this.effects.store.get({
                ...this.options,
                path: (0, util_1.extractJsonPath)(this.path),
                callback: () => callback(),
            });
            await waitForNext;
        }
    }
    /**
     * Watches the value of Store at the provided path. Takes a custom callback function to run whenever the value changes
     */
    onChange(callback) {
        ;
        (async () => {
            for await (const value of this.watch()) {
                try {
                    await callback(value);
                }
                catch (e) {
                    console.error("callback function threw an error @ GetStore.onChange", e);
                }
            }
        })()
            .catch((e) => callback(null, e))
            .catch((e) => console.error("callback function threw an error @ GetStore.onChange", e));
    }
}
exports.GetStore = GetStore;
function getStore(effects, path, options = {}) {
    return new GetStore(effects, path, options);
}
//# sourceMappingURL=getStore.js.map